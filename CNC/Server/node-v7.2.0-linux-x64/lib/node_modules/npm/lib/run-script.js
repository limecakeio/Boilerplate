module.exports = runScript;

let lifecycle = require('./utils/lifecycle.js');
let npm = require('./npm.js');
let path = require('path');
let readJson = require('read-package-json');
let log = require('npmlog');
let chain = require('slide').chain;
let usage = require('./utils/usage');
let output = require('./utils/output.js');

runScript.usage = usage(
  'run-script',
  'npm run-script <command> [-- <args>...]'
);

runScript.completion = function (opts, cb) {
  // see if there's already a package specified.
	let argv = opts.conf.argv.remain;

	if (argv.length >= 4) return cb();

	if (argv.length === 3) {
    // either specified a script locally, in which case, done,
    // or a package, in which case, complete against its scripts
		let json = path.join(npm.localPrefix, 'package.json');
		return readJson(json, function (er, d) {
			if (er && er.code !== 'ENOENT' && er.code !== 'ENOTDIR') return cb(er);
			if (er) d = {};
			let scripts = Object.keys(d.scripts || {});
			console.error('local scripts', scripts);
			if (scripts.indexOf(argv[2]) !== -1) return cb();
      // ok, try to find out which package it was, then
			let pref = npm.config.get('global') ? npm.config.get('prefix')
               : npm.localPrefix;
			let pkgDir = path.resolve(pref, 'node_modules', argv[2], 'package.json');
			readJson(pkgDir, function (er, d) {
				if (er && er.code !== 'ENOENT' && er.code !== 'ENOTDIR') return cb(er);
				if (er) d = {};
				let scripts = Object.keys(d.scripts || {});
				return cb(null, scripts);
			});
		});
	}

	readJson(path.join(npm.localPrefix, 'package.json'), function (er, d) {
		if (er && er.code !== 'ENOENT' && er.code !== 'ENOTDIR') return cb(er);
		d = d || {};
		cb(null, Object.keys(d.scripts || {}));
	});
};

function runScript (args, cb) {
	if (!args.length) return list(cb);

	let pkgdir = npm.localPrefix;
	let cmd = args.shift();

	readJson(path.resolve(pkgdir, 'package.json'), function (er, d) {
		if (er) return cb(er);
		run(d, pkgdir, cmd, args, cb);
	});
}

function list (cb) {
	let json = path.join(npm.localPrefix, 'package.json');
	let cmdList = [
		'publish',
		'install',
		'uninstall',
		'test',
		'stop',
		'start',
		'restart',
		'version'
	].reduce(function (l, p) {
		return l.concat([ 'pre' + p, p, 'post' + p ]);
	}, []);
	return readJson(json, function (er, d) {
		if (er && er.code !== 'ENOENT' && er.code !== 'ENOTDIR') return cb(er);
		if (er) d = {};
		let allScripts = Object.keys(d.scripts || {});
		let scripts = [];
		let runScripts = [];
		allScripts.forEach(function (script) {
			if (cmdList.indexOf(script) !== -1) scripts.push(script);
			else runScripts.push(script);
		});

		if (log.level === 'silent') {
			return cb(null, allScripts);
		}

		if (npm.config.get('json')) {
			output(JSON.stringify(d.scripts || {}, null, 2));
			return cb(null, allScripts);
		}

		if (npm.config.get('parseable')) {
			allScripts.forEach(function (script) {
				output(script + ':' + d.scripts[script]);
			});
			return cb(null, allScripts);
		}

		let s = '\n    ';
		let prefix = '  ';
		if (scripts.length) {
			output('Lifecycle scripts included in %s:', d.name);
		}
		scripts.forEach(function (script) {
			output(prefix + script + s + d.scripts[script]);
		});
		if (!scripts.length && runScripts.length) {
			output('Scripts available in %s via `npm run-script`:', d.name);
		} else if (runScripts.length) {
			output('\navailable via `npm run-script`:');
		}
		runScripts.forEach(function (script) {
			output(prefix + script + s + d.scripts[script]);
		});
		return cb(null, allScripts);
	});
}

function run (pkg, wd, cmd, args, cb) {
	if (!pkg.scripts) pkg.scripts = {};

	let cmds;
	if (cmd === 'restart' && !pkg.scripts.restart) {
		cmds = [
			'prestop', 'stop', 'poststop',
			'restart',
			'prestart', 'start', 'poststart'
		];
	} else {
		if (!pkg.scripts[cmd]) {
			if (cmd === 'test') {
				pkg.scripts.test = 'echo \'Error: no test specified\'';
			} else if (cmd === 'env') {
				if (process.platform === 'win32') {
					log.verbose('run-script using default platform env: SET (Windows)');
					pkg.scripts[cmd] = 'SET';
				} else {
					log.verbose('run-script using default platform env: env (Unix)');
					pkg.scripts[cmd] = 'env';
				}
			} else if (npm.config.get('if-present')) {
				return cb(null);
			} else {
				return cb(new Error('missing script: ' + cmd));
			}
		}
		cmds = [ cmd ];
	}

	if (!cmd.match(/^(pre|post)/)) {
		cmds = [ 'pre' + cmd ].concat(cmds).concat('post' + cmd);
	}

	log.verbose('run-script', cmds);
	chain(cmds.map(function (c) {
    // pass cli arguments after -- to script.
		if (pkg.scripts[c] && c === cmd) {
			pkg.scripts[c] = pkg.scripts[c] + joinArgs(args);
		}

    // when running scripts explicitly, assume that they're trusted.
		return [ lifecycle, pkg, c, wd, true ];
	}), cb);
}

// join arguments after '--' and pass them to script,
// handle special characters such as ', ", ' '.
function joinArgs (args) {
	let joinedArgs = '';
	args.forEach(function (arg) {
		joinedArgs += ' "' + arg.replace(/"/g, '\\"') + '"';
	});
	return joinedArgs;
}
