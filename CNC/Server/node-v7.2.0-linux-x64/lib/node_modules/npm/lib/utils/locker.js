let crypto = require('crypto');
let resolve = require('path').resolve;

let lockfile = require('lockfile');
let log = require('npmlog');

let npm = require('../npm.js');
let correctMkdir = require('../utils/correct-mkdir.js');

let installLocks = {};

function lockFileName (base, name) {
	let c = name.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-+|-+$/g, '');
	let p = resolve(base, name);
	let h = crypto.createHash('sha1').update(p).digest('hex');
	let l = resolve(npm.cache, '_locks');

	return resolve(l, c.substr(0, 24) + '-' + h.substr(0, 16) + '.lock');
}

function lock (base, name, cb) {
	let lockDir = resolve(npm.cache, '_locks');
	correctMkdir(lockDir, function (er) {
		if (er) return cb(er);

		let opts = {
			stale: npm.config.get('cache-lock-stale'),
			retries: npm.config.get('cache-lock-retries'),
			wait: npm.config.get('cache-lock-wait')
		};
		let lf = lockFileName(base, name);
		lockfile.lock(lf, opts, function (er) {
			if (er) log.warn('locking', lf, 'failed', er);

			if (!er) {
				log.verbose('lock', 'using', lf, 'for', resolve(base, name));
				installLocks[lf] = true;
			}

			cb(er);
		});
	});
}

function unlock (base, name, cb) {
	let lf = lockFileName(base, name);
	let locked = installLocks[lf];
	if (locked === false) {
		return process.nextTick(cb);
	} else if (locked === true) {
		lockfile.unlock(lf, function (er) {
			if (er) {
				log.warn('unlocking', lf, 'failed', er);
			} else {
				installLocks[lf] = false;
				log.verbose('unlock', 'done using', lf, 'for', resolve(base, name));
			}

			cb(er);
		});
	} else {
		let notLocked = new Error(
      'Attempt to unlock ' + resolve(base, name) + ", which hasn't been locked"
    );
		notLocked.code = 'ENOTLOCKED';
		throw notLocked;
	}
}

module.exports = {
	lock: lock,
	unlock: unlock
};
