
module.exports = unpublish;

let log = require('npmlog');
let npm = require('./npm.js');
let readJson = require('read-package-json');
let path = require('path');
let mapToRegistry = require('./utils/map-to-registry.js');
let npa = require('npm-package-arg');
let getPublishConfig = require('./utils/get-publish-config.js');
let output = require('./utils/output.js');

unpublish.usage = 'npm unpublish [<@scope>/]<pkg>[@<version>]';

unpublish.completion = function (opts, cb) {
	if (opts.conf.argv.remain.length >= 3) return cb();
	npm.commands.whoami([], true, function (er, username) {
		if (er) return cb();

		let un = encodeURIComponent(username);
		if (!un) return cb();
		let byUser = '-/by-user/' + un;
		mapToRegistry(byUser, npm.config, function (er, uri, auth) {
			if (er) return cb(er);

			npm.registry.get(uri, { auth: auth }, function (er, pkgs) {
        // do a bit of filtering at this point, so that we don't need
        // to fetch versions for more than one thing, but also don't
        // accidentally a whole project.
				pkgs = pkgs[un];
				if (!pkgs || !pkgs.length) return cb();
				let pp = npa(opts.partialWord).name;
				pkgs = pkgs.filter(function (p) {
					return p.indexOf(pp) === 0;
				});
				if (pkgs.length > 1) return cb(null, pkgs);
				mapToRegistry(pkgs[0], npm.config, function (er, uri, auth) {
					if (er) return cb(er);

					npm.registry.get(uri, { auth: auth }, function (er, d) {
						if (er) return cb(er);
						let vers = Object.keys(d.versions);
						if (!vers.length) return cb(null, pkgs);
						return cb(null, vers.map(function (v) {
							return pkgs[0] + '@' + v;
						}));
					});
				});
			});
		});
	});
};

function unpublish (args, cb) {
	if (args.length > 1) return cb(unpublish.usage);

	let thing = args.length ? npa(args[0]) : {};
	let project = thing.name;
	let version = thing.rawSpec;

	log.silly('unpublish', 'args[0]', args[0]);
	log.silly('unpublish', 'thing', thing);
	if (!version && !npm.config.get('force')) {
		return cb(
      'Refusing to delete entire project.\n' +
      'Run with --force to do this.\n' +
      unpublish.usage
    );
	}

	if (!project || path.resolve(project) === npm.localPrefix) {
    // if there's a package.json in the current folder, then
    // read the package name and version out of that.
		let cwdJson = path.join(npm.localPrefix, 'package.json');
		return readJson(cwdJson, function (er, data) {
			if (er && er.code !== 'ENOENT' && er.code !== 'ENOTDIR') return cb(er);
			if (er) return cb('Usage:\n' + unpublish.usage);
			log.verbose('unpublish', data);
			gotProject(data.name, data.version, data.publishConfig, cb);
		});
	}
	return gotProject(project, version, cb);
}

function gotProject (project, version, publishConfig, cb_) {
	if (typeof cb_ !== 'function') {
		cb_ = publishConfig;
		publishConfig = null;
	}

	function cb (er) {
		if (er) return cb_(er);
		output('- ' + project + (version ? '@' + version : ''));
		cb_();
	}

	let mappedConfig = getPublishConfig(publishConfig, npm.config, npm.registry);
	let config = mappedConfig.config;
	let registry = mappedConfig.client;

  // remove from the cache first
	npm.commands.cache([ 'clean', project, version ], function (er) {
		if (er) {
			log.error('unpublish', 'Failed to clean cache');
			return cb(er);
		}

		mapToRegistry(project, config, function (er, uri, auth) {
			if (er) return cb(er);

			let params = {
				version: version,
				auth: auth
			};
			registry.unpublish(uri, params, cb);
		});
	});
}
