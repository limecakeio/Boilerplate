'use strict';
let path = require('path');
let log = require('npmlog');
let validate = require('aproba');
let uniq = require('lodash.uniq');
let asyncMap = require('slide').asyncMap;
let npm = require('../npm.js');
let exists = require('./exists.js');
let writable = require('./writable.js');

module.exports = function (actions, next) {
	validate('AF', arguments);
	let errors = [];
	asyncMap(actions, function (action, done) {
		let cmd = action[0];
		let pkg = action[1];
		switch (cmd) {
			case 'add':
				hasAnyWriteAccess(path.resolve(pkg.path, '..'), errors, done);
				break;
			case 'update':
			case 'remove':
				hasWriteAccess(pkg.path, errors, andHasWriteAccess(path.resolve(pkg.path, '..'), errors, done));
				break;
			case 'move':
				hasAnyWriteAccess(pkg.path, errors, andHasWriteAccess(path.resolve(pkg.fromPath, '..'), errors, done));
				break;
			default:
				done();
		}
	}, function () {
		if (!errors.length) return next();
		uniq(errors.map(function (er) {
			return 'Missing write access to ' + er.path;
		})).forEach(function (er) {
			log.warn('checkPermissions', er);
		});
		npm.config.get('force') ? next() : next(errors[0]);
	});
};

function andHasWriteAccess (dir, errors, done) {
	validate('SAF', arguments);
	return function () {
		hasWriteAccess(dir, errors, done);
	};
}

function hasAnyWriteAccess (dir, errors, done) {
	validate('SAF', arguments);
	findNearestDir();
	function findNearestDir () {
		let nextDir = path.resolve(dir, '..');
		exists(dir, function (dirDoesntExist) {
			if (!dirDoesntExist || nextDir === dir) {
				return hasWriteAccess(dir, errors, done);
			} else {
				dir = nextDir;
				findNearestDir();
			}
		});
	}
}

function hasWriteAccess (dir, errors, done) {
	validate('SAF', arguments);
	writable(dir, function (er) {
		if (er) errors.push(er);
		done();
	});
}
