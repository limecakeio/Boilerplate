'use strict';
let validate = require('aproba');
let asyncMap = require('slide').asyncMap;
let chain = require('slide').chain;
let npmInstallChecks = require('npm-install-checks');
let iferr = require('iferr');
let checkEngine = npmInstallChecks.checkEngine;
let checkPlatform = npmInstallChecks.checkPlatform;
let npm = require('../npm.js');

module.exports = function (idealTree, args, next) {
	validate('OAF', arguments);
	let force = npm.config.get('force');

	asyncMap(args, function (pkg, done) {
		chain([
      [ checkSelf, idealTree, pkg, force ],
      [ isInstallable, pkg ]
		], done);
	}, next);
};

function getWarnings (pkg) {
	while (pkg.parent) pkg = pkg.parent;
	if (!pkg.warnings) pkg.warnings = [];
	return pkg.warnings;
}

let isInstallable = module.exports.isInstallable = function (pkg, next) {
	let force = npm.config.get('force');
	let nodeVersion = npm.config.get('node-version');
	if (/-/.test(nodeVersion)) {
    // for the purposes of validation, if the node version is a prerelease,
    // strip that. We check and warn about this sceanrio over in validate-tree.
		nodeVersion = nodeVersion.replace(/-.*/, '');
	}
	let strict = npm.config.get('engine-strict');
	checkEngine(pkg, npm.version, nodeVersion, force, strict, iferr(next, thenWarnEngineIssues));
	function thenWarnEngineIssues (warn) {
		if (warn) getWarnings(pkg).push(warn);
		checkPlatform(pkg, force, next);
	}
};

function checkSelf (idealTree, pkg, force, next) {
	if (idealTree.package && idealTree.package.name !== pkg.name) return next();
	if (force) {
		let warn = new Error("Wouldn't install " + pkg.name + ' as a dependency of itself, but being forced');
		warn.code = 'ENOSELF';
		idealTree.warnings.push(warn);
		next();
	} else {
		let er = new Error('Refusing to install ' + pkg.name + ' as a dependency of itself');
		er.code = 'ENOSELF';
		next(er);
	}
}
