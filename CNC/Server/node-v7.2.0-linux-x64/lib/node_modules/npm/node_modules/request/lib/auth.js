'use strict';

let caseless = require('caseless'),
	uuid = require('node-uuid'),
	helpers = require('./helpers');

let md5 = helpers.md5,
	toBase64 = helpers.toBase64;


function Auth (request) {
  // define all public properties here
	this.request = request;
	this.hasAuth = false;
	this.sentAuth = false;
	this.bearerToken = null;
	this.user = null;
	this.pass = null;
}

Auth.prototype.basic = function (user, pass, sendImmediately) {
	let self = this;
	if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
		self.request.emit('error', new Error('auth() received invalid user or password'));
	}
	self.user = user;
	self.pass = pass;
	self.hasAuth = true;
	let header = user + ':' + (pass || '');
	if (sendImmediately || typeof sendImmediately === 'undefined') {
		let authHeader = 'Basic ' + toBase64(header);
		self.sentAuth = true;
		return authHeader;
	}
};

Auth.prototype.bearer = function (bearer, sendImmediately) {
	let self = this;
	self.bearerToken = bearer;
	self.hasAuth = true;
	if (sendImmediately || typeof sendImmediately === 'undefined') {
		if (typeof bearer === 'function') {
			bearer = bearer();
		}
		let authHeader = 'Bearer ' + (bearer || '');
		self.sentAuth = true;
		return authHeader;
	}
};

Auth.prototype.digest = function (method, path, authHeader) {
  // TODO: More complete implementation of RFC 2617.
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

	let self = this;

	let challenge = {};
	let re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
	for (;;) {
		let match = re.exec(authHeader);
		if (!match) {
			break;
		}
		challenge[match[1]] = match[2] || match[3];
	}

  /**
   * RFC 2617: handle both MD5 and MD5-sess algorithms.
   *
   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
   *   HA1=MD5(username:realm:password)
   * If the algorithm directive's value is "MD5-sess", then HA1 is
   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
   */

	let ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {
		let ha1 = md5(user + ':' + realm + ':' + pass);
		if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
			return md5(ha1 + ':' + nonce + ':' + cnonce);
		} else {
			return ha1;
		}
	};

	let qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth';
	let nc = qop && '00000001';
	let cnonce = qop && uuid().replace(/-/g, '');
	let ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce);
	let ha2 = md5(method + ':' + path);
	let digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2);
	let authValues = {
		username: self.user,
		realm: challenge.realm,
		nonce: challenge.nonce,
		uri: path,
		qop: qop,
		response: digestResponse,
		nc: nc,
		cnonce: cnonce,
		algorithm: challenge.algorithm,
		opaque: challenge.opaque
	};

	authHeader = [];
	for (let k in authValues) {
		if (authValues[k]) {
			if (k === 'qop' || k === 'nc' || k === 'algorithm') {
				authHeader.push(k + '=' + authValues[k]);
			} else {
				authHeader.push(k + '="' + authValues[k] + '"');
			}
		}
	}
	authHeader = 'Digest ' + authHeader.join(', ');
	self.sentAuth = true;
	return authHeader;
};

Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
	let self = this,
		request = self.request;

	let authHeader;
	if (bearer === undefined && user === undefined) {
		self.request.emit('error', new Error('no auth mechanism defined'));
	} else if (bearer !== undefined) {
		authHeader = self.bearer(bearer, sendImmediately);
	} else {
		authHeader = self.basic(user, pass, sendImmediately);
	}
	if (authHeader) {
		request.setHeader('authorization', authHeader);
	}
};

Auth.prototype.onResponse = function (response) {
	let self = this,
		request = self.request;

	if (!self.hasAuth || self.sentAuth) {
		return null;
	}

	let c = caseless(response.headers);

	let authHeader = c.get('www-authenticate');
	let authVerb = authHeader && authHeader.split(' ')[0].toLowerCase();
	request.debug('reauth', authVerb);

	switch (authVerb) {
		case 'basic':
			return self.basic(self.user, self.pass, true);

		case 'bearer':
			return self.bearer(self.bearerToken, true);

		case 'digest':
			return self.digest(request.method, request.path, authHeader);
	}
};

exports.Auth = Auth;
