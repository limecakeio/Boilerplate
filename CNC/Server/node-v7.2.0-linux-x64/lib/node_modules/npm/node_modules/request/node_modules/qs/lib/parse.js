'use strict';

let Utils = require('./utils');

let has = Object.prototype.hasOwnProperty;

let defaults = {
	delimiter: '&',
	depth: 5,
	arrayLimit: 20,
	parameterLimit: 1000,
	strictNullHandling: false,
	plainObjects: false,
	allowPrototypes: false,
	allowDots: false,
	decoder: Utils.decode
};

let parseValues = function parseValues(str, options) {
	let obj = {};
	let parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	for (let i = 0; i < parts.length; ++i) {
		let part = parts[i];
		let pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

		var key, val;
		if (pos === -1) {
			key = options.decoder(part);
			val = options.strictNullHandling ? null : '';
		} else {
			key = options.decoder(part.slice(0, pos));
			val = options.decoder(part.slice(pos + 1));
		}
		if (has.call(obj, key)) {
			obj[key] = [].concat(obj[key]).concat(val);
		} else {
			obj[key] = val;
		}
	}

	return obj;
};

let parseObject = function parseObject(chain, val, options) {
	if (!chain.length) {
		return val;
	}

	let root = chain.shift();

	let obj;
	if (root === '[]') {
		obj = [];
		obj = obj.concat(parseObject(chain, val, options));
	} else {
		obj = options.plainObjects ? Object.create(null) : {};
		let cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
		let index = parseInt(cleanRoot, 10);
		if (
            !isNaN(index) &&
            root !== cleanRoot &&
            String(index) === cleanRoot &&
            index >= 0 &&
            (options.parseArrays && index <= options.arrayLimit)
        ) {
			obj = [];
			obj[index] = parseObject(chain, val, options);
		} else {
			obj[cleanRoot] = parseObject(chain, val, options);
		}
	}

	return obj;
};

let parseKeys = function parseKeys(givenKey, val, options) {
	if (!givenKey) {
		return;
	}

    // Transform dot notation to bracket notation
	let key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

    // The regex chunks

	let parent = /^([^\[\]]*)/;
	let child = /(\[[^\[\]]*\])/g;

    // Get the parent

	let segment = parent.exec(key);

    // Stash the parent if it exists

	let keys = [];
	if (segment[1]) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
		if (!options.plainObjects && has.call(Object.prototype, segment[1])) {
			if (!options.allowPrototypes) {
				return;
			}
		}

		keys.push(segment[1]);
	}

    // Loop through children appending to the array until we hit depth

	let i = 0;
	while ((segment = child.exec(key)) !== null && i < options.depth) {
		i += 1;
		if (!options.plainObjects && has.call(Object.prototype, segment[1].replace(/\[|\]/g, ''))) {
			if (!options.allowPrototypes) {
				continue;
			}
		}
		keys.push(segment[1]);
	}

    // If there's a remainder, just add whatever is left

	if (segment) {
		keys.push('[' + key.slice(segment.index) + ']');
	}

	return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
	let options = opts || {};

	if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
		throw new TypeError('Decoder has to be a function.');
	}

	options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	options.parseArrays = options.parseArrays !== false;
	options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	if (str === '' || str === null || typeof str === 'undefined') {
		return options.plainObjects ? Object.create(null) : {};
	}

	let tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	let obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

	let keys = Object.keys(tempObj);
	for (let i = 0; i < keys.length; ++i) {
		let key = keys[i];
		let newObj = parseKeys(key, tempObj[key], options);
		obj = Utils.merge(obj, newObj, options);
	}

	return Utils.compact(obj);
};
