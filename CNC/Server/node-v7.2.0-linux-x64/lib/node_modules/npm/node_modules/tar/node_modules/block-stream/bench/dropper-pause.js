let BlockStream = require("dropper");

let blockSizes = [ 16, 25, 1024 ],
	writeSizes = [ 4, 8, 15, 16, 17, 64, 100 ],
	writeCounts = [ 1, 10, 100 ],
	tap = require("tap");

writeCounts.forEach(function (writeCount) {
	blockSizes.forEach(function (blockSize) {
		writeSizes.forEach(function (writeSize) {
			tap.test("writeSize=" + writeSize +
           " blockSize=" + blockSize +
           " writeCount=" + writeCount, function (t) {
				let f = new BlockStream(blockSize, { nopad: true });

				let actualChunks = 0;
				let actualBytes = 0;
				let timeouts = 0;

				f.on("data", function (c) {
					timeouts++;

					actualChunks++;
					actualBytes += c.length;

      // make sure that no data gets corrupted, and basic sanity
					let before = c.toString();
      // simulate a slow write operation
					f.pause();
					setTimeout(function () {
						timeouts--;

						let after = c.toString();
						t.equal(after, before, "should not change data");

        // now corrupt it, to find leaks.
						for (let i = 0; i < c.length; i++) {
							c[i] = "x".charCodeAt(0);
						}
						f.resume();
					}, 100);
				});

				f.on("end", function () {
      // round up to the nearest block size
					let expectChunks = Math.ceil(writeSize * writeCount  * 2 / blockSize);
					let expectBytes = writeSize * writeCount * 2;
					t.equal(actualBytes, expectBytes,
              "bytes=" + expectBytes + " writeSize=" + writeSize);
					t.equal(actualChunks, expectChunks,
              "chunks=" + expectChunks + " writeSize=" + writeSize);

      // wait for all the timeout checks to finish, then end the test
					setTimeout(function WAIT () {
						if (timeouts > 0) return setTimeout(WAIT);
						t.end();
					}, 100);
				});

				for (let i = 0; i < writeCount; i++) {
					let a = new Buffer(writeSize);
					for (var j = 0; j < writeSize; j++) a[j] = "a".charCodeAt(0);
					let b = new Buffer(writeSize);
					for (var j = 0; j < writeSize; j++) b[j] = "b".charCodeAt(0);
					f.write(a);
					f.write(b);
				}
				f.end();
			});
		});
	});
});
