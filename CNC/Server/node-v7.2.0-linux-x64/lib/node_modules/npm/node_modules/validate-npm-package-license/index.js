let parse = require('spdx-expression-parse');
let correct = require('spdx-correct');

let genericWarning = (
  'license should be ' +
  'a valid SPDX license expression (without "LicenseRef"), ' +
  '"UNLICENSED", or ' +
  '"SEE LICENSE IN <filename>"'
);

let fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;

function startsWith(prefix, string) {
	return string.slice(0, prefix.length) === prefix;
}

function usesLicenseRef(ast) {
	if (ast.hasOwnProperty('license')) {
		let license = ast.license;
		return (
      startsWith('LicenseRef', license) ||
      startsWith('DocumentRef', license)
		);
	} else {
		return (
      usesLicenseRef(ast.left) ||
      usesLicenseRef(ast.right)
		);
	}
}

module.exports = function(argument) {
	let ast;

	try {
		ast = parse(argument);
	} catch (e) {
		let match;
		if (
      argument === 'UNLICENSED' ||
      argument === 'UNLICENCED'
    ) {
			return {
				validForOldPackages: true,
				validForNewPackages: true,
				unlicensed: true
			};
		} else if (match = fileReferenceRE.exec(argument)) {
			return {
				validForOldPackages: true,
				validForNewPackages: true,
				inFile: match[1]
			};
		} else {
			let result = {
				validForOldPackages: false,
				validForNewPackages: false,
				warnings: [ genericWarning ]
			};
			let corrected = correct(argument);
			if (corrected) {
				result.warnings.push(
          'license is similar to the valid expression "' + corrected + '"'
        );
			}
			return result;
		}
	}

	if (usesLicenseRef(ast)) {
		return {
			validForNewPackages: false,
			validForOldPackages: false,
			spdx: true,
			warnings: [ genericWarning ]
		};
	} else {
		return {
			validForNewPackages: true,
			validForOldPackages: true,
			spdx: true
		};
	}
};
