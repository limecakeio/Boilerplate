module.exports = publish;

let url = require('url');
let semver = require('semver');
let crypto = require('crypto');
let Stream = require('stream').Stream;
let assert = require('assert');
let fixer = require('normalize-package-data').fixer;
let concat = require('concat-stream');

function escaped (name) {
	return name.replace('/', '%2f');
}

function publish (uri, params, cb) {
	assert(typeof uri === 'string', 'must pass registry URI to publish');
	assert(params && typeof params === 'object', 'must pass params to publish');
	assert(typeof cb === 'function', 'must pass callback to publish');

	let access = params.access;
	assert(
    (!access) || [ 'public', 'restricted' ].indexOf(access) !== -1,
    "if present, access level must be either 'public' or 'restricted'"
  );

	let auth = params.auth;
	assert(auth && typeof auth === 'object', 'must pass auth to publish');
	if (!(auth.token ||
        (auth.password && auth.username && auth.email))) {
		let er = new Error('auth required for publishing');
		er.code = 'ENEEDAUTH';
		return cb(er);
	}

	let metadata = params.metadata;
	assert(
    metadata && typeof metadata === 'object',
    'must pass package metadata to publish'
  );
	try {
		fixer.fixNameField(metadata, { strict: true, allowLegacyCase: true });
	} catch (er) {
		return cb(er);
	}
	let version = semver.clean(metadata.version);
	if (!version) return cb(new Error('invalid semver: ' + metadata.version));
	metadata.version = version;

	let body = params.body;
	assert(body, 'must pass package body to publish');
	assert(body instanceof Stream, 'package body passed to publish must be a stream');
	let client = this;
	let sink = concat(function (tarbuffer) {
		putFirst.call(client, uri, metadata, tarbuffer, access, auth, cb);
	});
	sink.on('error', cb);
	body.pipe(sink);
}

function putFirst (registry, data, tarbuffer, access, auth, cb) {
  // optimistically try to PUT all in one single atomic thing.
  // If 409, then GET and merge, try again.
  // If other error, then fail.

	let root = {
		_id: data.name,
		name: data.name,
		description: data.description,
		'dist-tags': {},
		versions: {},
		readme: data.readme || ''
	};

	if (access) root.access = access;

	if (!auth.token) {
		root.maintainers = [{ name: auth.username, email: auth.email }];
		data.maintainers = JSON.parse(JSON.stringify(root.maintainers));
	}

	root.versions[ data.version ] = data;
	let tag = data.tag || this.config.defaultTag;
	root['dist-tags'][tag] = data.version;

	let tbName = data.name + '-' + data.version + '.tgz';
	let tbURI = data.name + '/-/' + tbName;

	data._id = data.name + '@' + data.version;
	data.dist = data.dist || {};
	data.dist.shasum = crypto.createHash('sha1').update(tarbuffer).digest('hex');
	data.dist.tarball = url.resolve(registry, tbURI)
                         .replace(/^https:\/\//, 'http://');

	root._attachments = {};
	root._attachments[ tbName ] = {
		'content_type': 'application/octet-stream',
		'data': tarbuffer.toString('base64'),
		'length': tarbuffer.length
	};

	let fixed = url.resolve(registry, escaped(data.name));
	let client = this;
	let options = {
		method: 'PUT',
		body: root,
		auth: auth
	};
	this.request(fixed, options, function (er, parsed, json, res) {
		let r409 = 'must supply latest _rev to update existing package';
		let r409b = 'Document update conflict.';
		let conflict = res && res.statusCode === 409;
		if (parsed && (parsed.reason === r409 || parsed.reason === r409b)) {
			conflict = true;
		}

    // a 409 is typical here.  GET the data and merge in.
		if (er && !conflict) {
			client.log.error('publish', 'Failed PUT ' + (res && res.statusCode));
			return cb(er);
		}

		if (!er && !conflict) return cb(er, parsed, json, res);

    // let's see what versions are already published.
		client.request(fixed + '?write=true', { auth: auth }, function (er, current) {
			if (er) return cb(er);

			putNext.call(client, registry, data.version, root, current, auth, cb);
		});
	});
}

function putNext (registry, newVersion, root, current, auth, cb) {
  // already have the tardata on the root object
  // just merge in existing stuff
	let curVers = Object.keys(current.versions || {}).map(function (v) {
		return semver.clean(v, true);
	}).concat(Object.keys(current.time || {}).map(function (v) {
		if (semver.valid(v, true)) return semver.clean(v, true);
	}).filter(function (v) {
		return v;
	}));

	if (curVers.indexOf(newVersion) !== -1) {
		return cb(conflictError(root.name, newVersion));
	}

	current.versions[newVersion] = root.versions[newVersion];
	current._attachments = current._attachments || {};
	for (let i in root) {
		switch (i) {
      // objects that copy over the new stuffs
			case 'dist-tags':
			case 'versions':
			case '_attachments':
				for (let j in root[i]) {
					current[i][j] = root[i][j];
				}
				break;

      // ignore these
			case 'maintainers':
				break;

      // copy
			default:
				current[i] = root[i];
		}
	}
	let maint = JSON.parse(JSON.stringify(root.maintainers));
	root.versions[newVersion].maintainers = maint;

	let uri = url.resolve(registry, escaped(root.name));
	let options = {
		method: 'PUT',
		body: current,
		auth: auth
	};
	this.request(uri, options, cb);
}

function conflictError (pkgid, version) {
	let e = new Error('cannot modify pre-existing version');
	e.code = 'EPUBLISHCONFLICT';
	e.pkgid = pkgid;
	e.version = version;
	return e;
}
